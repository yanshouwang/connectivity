// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'JStaticIpConfiguration.dart' as jstaticipconfiguration$_;

/// from: `dev.zeekr.connectivity.JIpConfiguration$Companion`
class JIpConfiguration$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<JIpConfiguration$Companion> $type;

  @jni$_.internal
  JIpConfiguration$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/connectivity/JIpConfiguration$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JIpConfiguration$Companion?> nullableType =
      $JIpConfiguration$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JIpConfiguration$Companion> type =
      $JIpConfiguration$Companion$Type$();
  static final _id_getClazz = _class.instanceMethodId(
    r'getClazz',
    r'()Ljava/lang/Class;',
  );

  static final _getClazz =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Class<?> getClazz()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getClazz() {
    return _getClazz(
      reference.pointer,
      _id_getClazz as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JIpConfiguration$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JIpConfiguration$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $JIpConfiguration$Companion$NullableType$
    extends jni$_.JType<JIpConfiguration$Companion?> {
  @jni$_.internal
  const $JIpConfiguration$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/connectivity/JIpConfiguration$Companion;';

  @jni$_.internal
  @core$_.override
  JIpConfiguration$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : JIpConfiguration$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<JIpConfiguration$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JIpConfiguration$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JIpConfiguration$Companion$NullableType$) &&
        other is $JIpConfiguration$Companion$NullableType$;
  }
}

final class $JIpConfiguration$Companion$Type$
    extends jni$_.JType<JIpConfiguration$Companion> {
  @jni$_.internal
  const $JIpConfiguration$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/connectivity/JIpConfiguration$Companion;';

  @jni$_.internal
  @core$_.override
  JIpConfiguration$Companion fromReference(jni$_.JReference reference) =>
      JIpConfiguration$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<JIpConfiguration$Companion?> get nullableType =>
      const $JIpConfiguration$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JIpConfiguration$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JIpConfiguration$Companion$Type$) &&
        other is $JIpConfiguration$Companion$Type$;
  }
}

/// from: `dev.zeekr.connectivity.JIpConfiguration$JIpAssignment$Companion`
class JIpConfiguration$JIpAssignment$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<JIpConfiguration$JIpAssignment$Companion> $type;

  @jni$_.internal
  JIpConfiguration$JIpAssignment$Companion.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/connectivity/JIpConfiguration$JIpAssignment$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JIpConfiguration$JIpAssignment$Companion?>
  nullableType = $JIpConfiguration$JIpAssignment$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JIpConfiguration$JIpAssignment$Companion> type =
      $JIpConfiguration$JIpAssignment$Companion$Type$();
  static final _id_getClazz = _class.instanceMethodId(
    r'getClazz',
    r'()Ljava/lang/Class;',
  );

  static final _getClazz =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Class<?> getClazz()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getClazz() {
    return _getClazz(
      reference.pointer,
      _id_getClazz as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_of = _class.instanceMethodId(
    r'of',
    r'(Ljava/lang/Object;)Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun of(obj: kotlin.Any): dev.zeekr.connectivity.JIpConfiguration.JIpAssignment`
  /// The returned object must be released after use, by calling the [release] method.
  JIpConfiguration$JIpAssignment of(jni$_.JObject object) {
    final _$object = object.reference;
    return _of(
      reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<JIpConfiguration$JIpAssignment>(
      const $JIpConfiguration$JIpAssignment$Type$(),
    );
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JIpConfiguration$JIpAssignment$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JIpConfiguration$JIpAssignment$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $JIpConfiguration$JIpAssignment$Companion$NullableType$
    extends jni$_.JType<JIpConfiguration$JIpAssignment$Companion?> {
  @jni$_.internal
  const $JIpConfiguration$JIpAssignment$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment$Companion;';

  @jni$_.internal
  @core$_.override
  JIpConfiguration$JIpAssignment$Companion? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : JIpConfiguration$JIpAssignment$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<JIpConfiguration$JIpAssignment$Companion?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($JIpConfiguration$JIpAssignment$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JIpConfiguration$JIpAssignment$Companion$NullableType$) &&
        other is $JIpConfiguration$JIpAssignment$Companion$NullableType$;
  }
}

final class $JIpConfiguration$JIpAssignment$Companion$Type$
    extends jni$_.JType<JIpConfiguration$JIpAssignment$Companion> {
  @jni$_.internal
  const $JIpConfiguration$JIpAssignment$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment$Companion;';

  @jni$_.internal
  @core$_.override
  JIpConfiguration$JIpAssignment$Companion fromReference(
    jni$_.JReference reference,
  ) => JIpConfiguration$JIpAssignment$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<JIpConfiguration$JIpAssignment$Companion?> get nullableType =>
      const $JIpConfiguration$JIpAssignment$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($JIpConfiguration$JIpAssignment$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JIpConfiguration$JIpAssignment$Companion$Type$) &&
        other is $JIpConfiguration$JIpAssignment$Companion$Type$;
  }
}

/// from: `dev.zeekr.connectivity.JIpConfiguration$JIpAssignment`
class JIpConfiguration$JIpAssignment extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<JIpConfiguration$JIpAssignment> $type;

  @jni$_.internal
  JIpConfiguration$JIpAssignment.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/connectivity/JIpConfiguration$JIpAssignment',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JIpConfiguration$JIpAssignment?> nullableType =
      $JIpConfiguration$JIpAssignment$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JIpConfiguration$JIpAssignment> type =
      $JIpConfiguration$JIpAssignment$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment$Companion;',
  );

  /// from: `static public final dev.zeekr.connectivity.JIpConfiguration$JIpAssignment$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JIpConfiguration$JIpAssignment$Companion get Companion => _id_Companion
      .get(_class, const $JIpConfiguration$JIpAssignment$Companion$Type$());

  static final _id_STATIC = _class.staticFieldId(
    r'STATIC',
    r'Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;',
  );

  /// from: `static public final dev.zeekr.connectivity.JIpConfiguration$JIpAssignment STATIC`
  /// The returned object must be released after use, by calling the [release] method.
  static JIpConfiguration$JIpAssignment get STATIC =>
      _id_STATIC.get(_class, const $JIpConfiguration$JIpAssignment$Type$());

  static final _id_DHCP = _class.staticFieldId(
    r'DHCP',
    r'Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;',
  );

  /// from: `static public final dev.zeekr.connectivity.JIpConfiguration$JIpAssignment DHCP`
  /// The returned object must be released after use, by calling the [release] method.
  static JIpConfiguration$JIpAssignment get DHCP =>
      _id_DHCP.get(_class, const $JIpConfiguration$JIpAssignment$Type$());

  static final _id_UNASSIGNED = _class.staticFieldId(
    r'UNASSIGNED',
    r'Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;',
  );

  /// from: `static public final dev.zeekr.connectivity.JIpConfiguration$JIpAssignment UNASSIGNED`
  /// The returned object must be released after use, by calling the [release] method.
  static JIpConfiguration$JIpAssignment get UNASSIGNED =>
      _id_UNASSIGNED.get(_class, const $JIpConfiguration$JIpAssignment$Type$());

  static final _id_getObj = _class.instanceMethodId(
    r'getObj',
    r'()Ljava/lang/Object;',
  );

  static final _getObj =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getObj()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getObj() {
    return _getObj(
      reference.pointer,
      _id_getObj as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public dev.zeekr.connectivity.JIpConfiguration$JIpAssignment[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<JIpConfiguration$JIpAssignment?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<JIpConfiguration$JIpAssignment?>?>(
      const jni$_.$JArray$NullableType$<JIpConfiguration$JIpAssignment?>(
        $JIpConfiguration$JIpAssignment$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public dev.zeekr.connectivity.JIpConfiguration$JIpAssignment valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static JIpConfiguration$JIpAssignment? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<JIpConfiguration$JIpAssignment?>(
      const $JIpConfiguration$JIpAssignment$NullableType$(),
    );
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public kotlin.enums.EnumEntries<dev.zeekr.connectivity.JIpConfiguration$JIpAssignment> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
      _class.reference.pointer,
      _id_getEntries as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }
}

final class $JIpConfiguration$JIpAssignment$NullableType$
    extends jni$_.JType<JIpConfiguration$JIpAssignment?> {
  @jni$_.internal
  const $JIpConfiguration$JIpAssignment$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;';

  @jni$_.internal
  @core$_.override
  JIpConfiguration$JIpAssignment? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : JIpConfiguration$JIpAssignment.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<JIpConfiguration$JIpAssignment?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JIpConfiguration$JIpAssignment$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JIpConfiguration$JIpAssignment$NullableType$) &&
        other is $JIpConfiguration$JIpAssignment$NullableType$;
  }
}

final class $JIpConfiguration$JIpAssignment$Type$
    extends jni$_.JType<JIpConfiguration$JIpAssignment> {
  @jni$_.internal
  const $JIpConfiguration$JIpAssignment$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;';

  @jni$_.internal
  @core$_.override
  JIpConfiguration$JIpAssignment fromReference(jni$_.JReference reference) =>
      JIpConfiguration$JIpAssignment.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<JIpConfiguration$JIpAssignment?> get nullableType =>
      const $JIpConfiguration$JIpAssignment$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JIpConfiguration$JIpAssignment$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JIpConfiguration$JIpAssignment$Type$) &&
        other is $JIpConfiguration$JIpAssignment$Type$;
  }
}

/// from: `dev.zeekr.connectivity.JIpConfiguration`
class JIpConfiguration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<JIpConfiguration> $type;

  @jni$_.internal
  JIpConfiguration.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/connectivity/JIpConfiguration',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JIpConfiguration?> nullableType =
      $JIpConfiguration$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JIpConfiguration> type = $JIpConfiguration$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Ldev/zeekr/connectivity/JIpConfiguration$Companion;',
  );

  /// from: `static public final dev.zeekr.connectivity.JIpConfiguration$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JIpConfiguration$Companion get Companion =>
      _id_Companion.get(_class, const $JIpConfiguration$Companion$Type$());

  static final _id_new$ = _class.constructorId(r'(Ljava/lang/Object;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JIpConfiguration(jni$_.JObject object) {
    final _$object = object.reference;
    return JIpConfiguration.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$object.pointer,
      ).reference,
    );
  }

  static final _id_getObj = _class.instanceMethodId(
    r'getObj',
    r'()Ljava/lang/Object;',
  );

  static final _getObj =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getObj()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getObj() {
    return _getObj(
      reference.pointer,
      _id_getObj as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_getIpAssignment = _class.instanceMethodId(
    r'getIpAssignment',
    r'()Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;',
  );

  static final _getIpAssignment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final dev.zeekr.connectivity.JIpConfiguration$JIpAssignment getIpAssignment()`
  /// The returned object must be released after use, by calling the [release] method.
  JIpConfiguration$JIpAssignment getIpAssignment() {
    return _getIpAssignment(
      reference.pointer,
      _id_getIpAssignment as jni$_.JMethodIDPtr,
    ).object<JIpConfiguration$JIpAssignment>(
      const $JIpConfiguration$JIpAssignment$Type$(),
    );
  }

  static final _id_setIpAssignment = _class.instanceMethodId(
    r'setIpAssignment',
    r'(Ldev/zeekr/connectivity/JIpConfiguration$JIpAssignment;)V',
  );

  static final _setIpAssignment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void setIpAssignment(dev.zeekr.connectivity.JIpConfiguration$JIpAssignment jIpAssignment)`
  void setIpAssignment(JIpConfiguration$JIpAssignment jIpAssignment) {
    final _$jIpAssignment = jIpAssignment.reference;
    _setIpAssignment(
      reference.pointer,
      _id_setIpAssignment as jni$_.JMethodIDPtr,
      _$jIpAssignment.pointer,
    ).check();
  }

  static final _id_getStaticIpConfiguration = _class.instanceMethodId(
    r'getStaticIpConfiguration',
    r'()Ldev/zeekr/connectivity/JStaticIpConfiguration;',
  );

  static final _getStaticIpConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final dev.zeekr.connectivity.JStaticIpConfiguration getStaticIpConfiguration()`
  /// The returned object must be released after use, by calling the [release] method.
  jstaticipconfiguration$_.JStaticIpConfiguration? getStaticIpConfiguration() {
    return _getStaticIpConfiguration(
      reference.pointer,
      _id_getStaticIpConfiguration as jni$_.JMethodIDPtr,
    ).object<jstaticipconfiguration$_.JStaticIpConfiguration?>(
      const jstaticipconfiguration$_.$JStaticIpConfiguration$NullableType$(),
    );
  }

  static final _id_setStaticIpConfiguration = _class.instanceMethodId(
    r'setStaticIpConfiguration',
    r'(Ldev/zeekr/connectivity/JStaticIpConfiguration;)V',
  );

  static final _setStaticIpConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void setStaticIpConfiguration(dev.zeekr.connectivity.JStaticIpConfiguration jStaticIpConfiguration)`
  void setStaticIpConfiguration(
    jstaticipconfiguration$_.JStaticIpConfiguration? jStaticIpConfiguration,
  ) {
    final _$jStaticIpConfiguration =
        jStaticIpConfiguration?.reference ?? jni$_.jNullReference;
    _setStaticIpConfiguration(
      reference.pointer,
      _id_setStaticIpConfiguration as jni$_.JMethodIDPtr,
      _$jStaticIpConfiguration.pointer,
    ).check();
  }
}

final class $JIpConfiguration$NullableType$
    extends jni$_.JType<JIpConfiguration?> {
  @jni$_.internal
  const $JIpConfiguration$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ldev/zeekr/connectivity/JIpConfiguration;';

  @jni$_.internal
  @core$_.override
  JIpConfiguration? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : JIpConfiguration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<JIpConfiguration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JIpConfiguration$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JIpConfiguration$NullableType$) &&
        other is $JIpConfiguration$NullableType$;
  }
}

final class $JIpConfiguration$Type$ extends jni$_.JType<JIpConfiguration> {
  @jni$_.internal
  const $JIpConfiguration$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ldev/zeekr/connectivity/JIpConfiguration;';

  @jni$_.internal
  @core$_.override
  JIpConfiguration fromReference(jni$_.JReference reference) =>
      JIpConfiguration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<JIpConfiguration?> get nullableType =>
      const $JIpConfiguration$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JIpConfiguration$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JIpConfiguration$Type$) &&
        other is $JIpConfiguration$Type$;
  }
}
